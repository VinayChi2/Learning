>Unix is a computer Operating System which is capable of handling activities from multiple users at the same time
------------------------------------------------------------------
>ls -l

drwxrwxr-x  2 amrood amrood      4096 Dec 25 09:59 uml
-rw-rw-r--  1 amrood amrood      5341 Dec 25 08:38 uml.jpg
drwxr-xr-x  2 amrood amrood      4096 Feb 15  2006 univ
drwxr-xr-x  2 root   root        4096 Dec  9  2007 urlspedia

Second Column − Represents the number of memory blocks taken by the file or directory.

Third Column − Represents the owner of the file. This is the Unix user who created this file.

Fourth Column − Represents the group of the owner. Every Unix user will have an associated group.


In the ls -l listing example, every file line begins with a d, -, or l. These characters indicate the type of the file that's listed.

Sr.No.	Prefix & Description
1)	-

Regular file, such as an ASCII text file, binary executable, or hard link.

2)	b

Block special file. Block input/output device file such as a physical hard drive.

3)	c

Character special file. Raw input/output device file such as a physical hard drive.

4)	d

Directory file that contains a listing of other files and directories

5)	l

Symbolic link file. Links on any regular file.

6)	p

Named pipe. A mechanism for interprocess communications.

7)	s

Socket used for interprocess communication.

-------------------------------------------------------------------------------------

Hidden Files
An invisible file is one, the first character of which is the dot or the period character (.).
Some common examples of the hidden files include the files −

.profile − The Bourne shell ( sh) initialization script

.kshrc − The Korn shell ( ksh) initialization script

To list the invisible files, specify the -a option to ls −

$ ls -a

.         .profile       docs     lib     test_results
..        .rhosts        hosts    pub     users
.emacs    bin            hw1      res.01  work
.exrc     ch07           hw2      res.02
.kshrc    ch07.bak       hw3      res.03
$
Single dot (.) − This represents the current directory.

Double dot (..) − This represents the parent directory.
--------------------------------------------------------------------------------

You can display the line numbers by using the -b option along with the cat command as follows −

$ cat -b filename
1   This is unix file....I created it for the first time.....
2   I'm going to save this content in this file.
$

-----------------------------------------------------------
$ wc filename
2  19 103 filename
$
Here is the detail of all the four columns −

First Column − Represents the total number of lines in the file.

Second Column − Represents the total number of words in the file.

Third Column − Represents the total number of bytes in the file. This is the actual size of the file.

Fourth Column − Represents the file name.
--------------------------------------------------------------
To change the name of a file, use the mv command. Following is the basic syntax −

$ mv old_file new_file
--------------------------------------------------------------------------------
Standard Unix Streams
Under normal circumstances, every Unix program has three streams (files) opened for it when it starts up −

stdin − This is referred to as the standard input and the associated file descriptor is 0. 
        This is also represented as STDIN. The Unix program will read the default input from STDIN.

stdout − This is referred to as the standard output and the associated file descriptor is 1.
         This is also represented as STDOUT. The Unix program will write the default output at STDOUT

stderr − This is referred to as the standard error and the associated file descriptor is 2.
         This is also represented as STDERR. The Unix program will write all the error messages at STDERR.



When you log in to the system, the shell undergoes a phase called initialization to set up the environment.
 This is usually a two-step process that involves the shell reading the following files −

/etc/profile
profile
The process is as follows −

The shell checks to see whether the file /etc/profile exists.

If it exists, the shell reads it. Otherwise, this file is skipped. No error message is displayed.

The shell checks to see whether the file .profile exists in your home directory. Your home directory is the directory that you start out in after you log in.

If it exists, the shell reads it; otherwise, the shell skips it. No error message is displayed.

As soon as both of these files have been read, the shell displays a prompt −

$

-----------------------------------------------------------------------------------------
Word and Character Searching
The vi editor has two kinds of searches: string and character. For a string search, the / and ? commands are used. When you start these commands, the command just typed will be shown on the last line of the screen, where you type the particular string to look for.

These two commands differ only in the direction where the search takes place −

The / command searches forwards (downwards) in the file.

The ? command searches backwards (upwards) in the file.

The n and N commands repeat the previous search command in the same or the opposite direction, respectively. Some characters have special meanings. These characters must be preceded by a backslash (\) to be included as part of the search expression.

Sr.No.	Character &Description
1	
^

Searches at the beginning of the line (Use at the beginning of a search expression).

2	
.

Matches a single character.

3	
*

Matches zero or more of the previous character.

4	
$

End of the line (Use at the end of the search expression).

5	
[

Starts a set of matching or non-matching expressions.

6	
<

This is put in an expression escaped with the backslash to find the ending or the beginning of a word.

7	
>

This helps see the '<' character description above.

The character search searches within one line to find a character entered after the command. The f and F commands search for a character on the current line only. f searches forwards and F searches backwards and the cursor moves to the position of the found character.

The t and T commands search for a character on the current line only, but for t, the cursor moves to the position before the character, and T searches the line backwards to the position after the character.

---------------------------------------------------------------------------------
Starting a Process
When you start a process (run a command), there are two ways you can run it −

Foreground Processes
Background Processes

Foreground Processes
By default, every process that you start runs in the foreground. It gets its input from the keyboard and sends its output to the screen.

You can see this happen with the ls command. If you wish to list all the files in your current directory, you can use the following command −

$ls ch*.doc

This would display all the files, the names of which start with ch and end with .doc −

ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc
The process runs in the foreground, the output is directed to my screen, and if the ls command wants any input (which it does not), 
it waits for it from the keyboard.

While a program is running in the foreground and is time-consuming, no other commands can be run (start any other processes) because the prompt would not be available until the program finishes processing and comes out.

Background Processes
A background process runs without being connected to your keyboard.
 If the background process requires any keyboard input, it waits.

The advantage of running a process in the background is that you can run other commands; 
you do not have to wait until it completes to start another!

The simplest way to start a background process is to add an ampersand (&) at the end of the command.

$ls ch*.doc &
This displays all those files the names of which start with ch and end with .doc −

ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc


---------------------------------------------


ps (process status)

ps -f

One of the most commonly used flags for ps is the -f ( f for full) option, which provides more information as shown in the following example −

$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f
Here is the description of all the fields displayed by ps -f command −

Sr.No.	Column & Description
1	
UID

User ID that this process belongs to (the person running it)

2	
PID

Process ID

3	
PPID

Parent process ID (the ID of the process that started it)

4	
C

CPU utilization of process

5	
STIME

Process start time

6	
TTY

Terminal type associated with the process

7	
TIME

CPU time taken by the process

8	
CMD

The command that started this process









